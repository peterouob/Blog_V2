---
title: OS恐龍書第10版1~5章答案
description: 解答
date: 2025-03-27
tags: ["note"]
---

# 第一章

## 1.1 作業系統的三個主要目的是什麼？

提供使用者介面

管理系統資源（如CPU、記憶體、I/O設備）

提供與硬體的抽象化與控制，方便應用程式使用

## 1.2 我們強調了作業系統對有效利用計算硬體的需求。作業系統什麼時候像放棄該原則，"浪費"資源？為什麼這種情況下作業系統這樣做是合理的？
當人機互動或系統反應時間變得重要時，例如為了提升使用者體驗，作業系統可能會預留資源，或使用多工方式降低硬體使用率，以換取更好的即時性與互動性。這種資源“浪費”是合理的，因為它改善了系統的易用性與回應速度。

## 1.3 程式設計師為開發環境撰寫作業系統時必須克服的主要困難是什麼？
需處理低階硬體細節（如記憶體管理、中斷處理、裝置驅動等），同時保證系統穩定、安全及效能；還要支援多使用者與多工作負載。

1.4 留意作業系統的各種定義，請考慮作業系統是否應包括網頁瀏覽器和類似程式的應用程式。請說明你的答案來解釋它應該或不應該。
作業系統的核心應只包括核心功能（kernel），如資源管理與硬體控制。網頁瀏覽器屬於應用程式，應不屬於作業系統的一部分。但某些作業系統（如Chrome OS）模糊了界線，這是實作設計選擇。

## 1.5 核心模式和使用者模式之間的區別如何作為保護（安全）的基本形式？
核心模式允許執行所有指令與存取所有資源，使用者模式則受到限制，防止應用程式對系統造成損壞。這種區隔可防止惡意或錯誤程式破壞系統資源，是基本的安全機制。

## 1.6 以下哪些指令應具有特權？
具有特權的操作通常涉及硬體控制或作業系統核心功能，包括：
1. 設置計時器的值
2. 讀寫記憶體
3. 發出陷阱指令
4. 關閉中斷
5. 修改設備狀態表中的表格
6. 從使用者模式切換到核心模式
7. 存取 I/O 設備

## 1.7 一些早期的電腦把作業系統放置在使用者或作業系統本身都無法修改的記憶體位置。請描述這種方式來保護作業系統。描述一下您認為這種方案可能產生的兩個難題。
這種方式是透過硬體保護讓作業系統程式無法被修改，增加安全性。
難題：

無法更新或修補作業系統漏洞

系統靈活度差，難以擴充功能或除錯

## 1.8 有些 CPU 提供兩種以上的操作模式，這些多種模式的兩種可能用途是什麼？

增加安全性（如：使用者模式、核心模式、中斷模式）

控制不同類型的執行環境（如虛擬機、即時處理等）

## 1.9 計時器可用來計數目前的時間。請簡短說明如何完成此操作。
CPU 中的時鐘每隔固定時間產生一個中斷，作業系統透過中斷處理程序遞增計時器，從而計算時間。

## 1.10 討論使用快取的兩個原因。它們解決什麼問題？它們會導致什麼問題？如果快取和主體儲存裝置（例如記憶體或磁碟）不一致，為什麼不將其建立如此大並直接取代記憶體？
原因與優點：

減少存取延遲，提高效能

降低對主體儲存的頻繁操作
問題：

資料不一致（cache coherence）

增加設計與管理複雜度
不能取代原因：
快取成本高、容量受限、不適合儲存大量資料或長期儲存。

## 1.11 請區分客戶端－伺服器及點對點的分散式系統。

客戶端－伺服器（Client-Server）： 客戶端發出請求，伺服器提供資源或服務（如網站）。

點對點（P2P）： 每個節點都可以是客戶或伺服器，彼此共享資源（如BT下載）。

# 第二章

## 2.1 系統呼叫的目的為何？
提供應用程式與作業系統核心之間的介面，讓使用者程式可請求作業系統提供服務（如檔案操作、程序控制、I/O處理等）。

## 2.2 命令解譯器的目的為何？為什麼通常與核心分開？
目的：接收使用者輸入指令並將其解譯為可執行的系統命令或程式。

分開原因：解譯器為使用者層的應用程式，方便修改、更新；與核心分離可提升系統模組化、彈性與安全性。

## 2.3 為了在 UNIX 系統上啟動新行程，哪些系統呼叫必須由命令解譯器或 shell 執行？
通常包含：

fork()：建立子行程

exec()（如 execve()）：載入與執行新程式

wait()：等待子行程結束

exit()：結束行程

## 2.4 系統程式的目的為何？
系統程式提供使用者與作業系統之間的操作工具，例如編輯器、編譯器、檔案管理工具，使使用者更方便使用系統功能。

## 2.5 分層方法進行系統設計的主要優點是什麼？分層方法的缺點是什麼？
優點： 易於設計、除錯與維護；每層只與上下層互動，降低耦合。

缺點： 定義層與層之間的明確界線不易；高層可能需多次呼叫底層造成效能損耗。

## 2.6 列出作業系統提供的五種服務，並說明每種服務的方式帶給使用者便利。在哪種情況下，使用者程式也能提供這些服務？說明你的答案。
常見五種服務：

程式執行

I/O 操作

檔案系統管理

通訊（行程間通訊）

錯誤偵測與安全保護

使用者程式可實作部分功能（如文字處理、壓縮軟體等），但無法直接存取硬體或關鍵資源，因此仍需倚賴作業系統提供介面。

## 2.7 為什麼某些系統將作業系統儲存在韌體中，而其它儲存在磁碟上？
韌體： 提供基本啟動與低層功能，嵌入式系統常見，開機速度快。

磁碟： 可更新與擴充，適用於通用作業系統。
- 取決於系統需求與可更新性。

## 2.8 如何設計系統以允許選擇作業系統從哪裡啟動？啟動程式需要做些什麼？
系統BIOS或UEFI提供選擇開機裝置（如HDD、USB、網路）。

啟動程式（如GRUB）負責載入作業系統核心至記憶體，初始化系統並開始執行。

# 第三章

## 3.1 使用圖 3.30 所示的程式：說明 LINE A 的輸出是什麼？
```c
int value = 5;
...
pid = fork();
if (pid == 0) {
    value = 15;
    return 0;
} else {
    wait(NULL);
    printf("PARENT: value = %d", value);  // LINE A
}
```
答案：
value 是一個在 fork() 之前宣告的變數。fork() 會複製整個行程空間，子行程對 value 的修改不會影響到父行程。因此輸出為：

PARENT: value = 5
## 3.2 圖 3.31 的程式建立了多少個行程？
```c
int main()
{
    fork();
    fork();
    fork();
}
```
每個 fork() 都會使目前的行程數加倍。

分析：

初始有 1 個行程

第一次 fork：1 → 2

第二次 fork：2 → 4

第三次 fork：4 → 8

總共建立了 7 個子行程（包含原本的 1 個，共 8 個）

## 3.3 iOS 作業系統未來將採進什麼樣的多行程方式？為什麼重要？
iOS 為了安全性與穩定性，限制應用程式使用多行程。未來的進程模型可能會改進以支援背景多工、安全隔離等。重點在於如何實現高效能與安全的多工處理。

## 3.4 有些系統使用多執行緒行程模型，若執行緒在核心中，且阻塞時 CPU 無法處理其他執行緒，會怎樣？
效能會降低

若一個執行緒阻塞，整個行程都不能繼續

解決方法：使用多對多或一對一執行緒模型，避免全程阻塞

## 3.5 當程式使用 fork() 建立新行程時，父子行程會共享哪些？
a. 堆疊（Stack） ：各有自己的堆疊空間
b. 堆區（Heap）：fork 時會複製，不共享（除非使用 shared memory）
c. 共用記憶體區段（Shared memory)：如果特別使用 shmget 或 mmap 建立，則可以共享

## 3.6 關於 RPC 的「恰好一次」語意（at-most-once）
RPC 設計要保證通訊錯誤時不會重複執行（例如網路延遲造成重送），否則可能導致副作用（如錢轉兩次）。
→ 需加入識別碼、確認訊息（ACK）與重傳控制（timeout）來確保恰好執行一次。

## 3.7 如果分散式系統要實現 RPC 的「恰好一次」語意，需定義什麼？
傳送端必須標記請求（編號）

接收端需能檢查是否為已執行過的請求（具備儲存歷史）

加入 ACK 機制 + 超時重傳

保證即使傳輸錯誤或重送，只執行一次副作用

# 第四章

## 4.1 多執行緒比單執行緒提供更好的性能，請提供三個程式實例說明。
網頁伺服器：同時處理多個用戶請求，每個請求一個執行緒。

圖形編輯軟體：主執行緒負責 UI，其它執行緒可同時處理特效或過濾器運算。

即時遊戲：一個執行緒處理使用者輸入，另一個處理遊戲邏輯，第三個處理音效或網路。

## 4.2 使用四類處理器架構，分別計算具有 60% 平行性的應用程式加速益（a）兩個處理器核心，（b）四個處理器核心。
使用 Amdahl’s Law 計算：
公式為

$Speedup= 1/(1-P)+P/N$



## 4.3 說明描述的多執行緒模型之間的區別？在哪種情況下，哪個模型比另一個更適用？
三種模型：

多對一（Many-to-One）：多個使用者執行緒對應一個核心執行緒，無法利用多核心，易堵塞。

一對一（One-to-One）：每個使用者執行緒對應一個核心執行緒，並行性佳但成本高。

多對多（Many-to-Many）：多個使用者執行緒對應多個核心執行緒，兼顧彈性與效率。

適用情況：

多對一：小型嵌入式系統

一對一：需要高效能並行

多對多：需彈性調整資源利用

## 4.4 使用者執行緒與核心執行緒的區別？
使用者執行緒：由使用者程式庫管理，不需進入核心，切換快但遇 I/O 可能整體阻塞。

核心執行緒：由作業系統管理，支援真正平行，I/O 時不會影響其他執行緒，但切換成本高。

## 4.5 建立執行緒時使用 fork() 系統呼叫與使用執行緒 API 有何不同？
fork()：建立全新行程，複製整個記憶體空間（較慢）

執行緒 API（如 pthread_create）：只建立新執行緒，共享相同地址空間（較快、資源共享）

## 4.6 為什麼業務系統常使用多執行緒執行，而非建立多行程？
節省資源（如記憶體、建立開銷小）

可共享資料（如快取、檔案）

響應速度更快，支援大量並發請求

## 4.7 描述 LWP（輕量級行程），並說明它與傳統的執行緒有何不同？
LWP：位於使用者執行緒與核心執行緒中間，是核心可識別與排程的單位

差異：使用者執行緒無法被核心直接管理，而 LWP 是 OS 可排程單位，可對應到多核心處理

# 第五章

## 5.1
題目： 給定要在一個處理器上排班的 n 個行程，可能有多少種不同排班方式？
答案：
如果所有行程沒有優先權且不允許重複，則總共有 n! 種排法（即階乘）。
例如 3 個行程：3! = 6 種排法。

## 5.2
可搶先與不可搶先排班的差異：

可搶先（Preemptive）：正在執行的行程可以被中斷，讓位給高優先權的行程（如 RR、SRTF）。

不可搶先（Non-preemptive）：行程一旦執行，必須執行完才能換其他行程（如 FCFS、SJF）。

## 5.3
行程資訊：
行程	到達時間	分割時間
P₁	0	8
P₂	0.4	4
P₃	1.0	1
a. 使用 FCFS（First-Come, First-Served）：
順序為 P₁ → P₂ → P₃
計算回復時間（Completion - 到達時間）：

P₁: 完成於 8，回復時間 = 8 - 0 = 8

P₂: 完成於 12，回復時間 = 12 - 0.4 = 11.6

P₃: 完成於 13，回復時間 = 13 - 1.0 = 12

平均回復時間 = (8 + 11.6 + 12) / 3 = 約 10.53

1. 使用 SJF（Shortest Job First）：
排程順序依照到達時可見的最短工作選擇：

0 時只有 P₁，故 P₁ 執行

執行完後選擇 P₃（最短）、再 P₂

→ 順序：P₁ → P₃ → P₂

P₁: 完成於 8，回復 = 8 - 0 = 8

P₃: 完成於 9，回復 = 9 - 1.0 = 8

P₂: 完成於 13，回復 = 13 - 0.4 = 12.6

平均回復時間 = (8 + 8 + 12.6) / 3 ≈ 9.53

2. SJF 不知未來，初始先執行 P₁ 的結果：
同 b → P₁ → P₃ → P₂（SJF在 P₁ 完成後才挑剩下最短）

→ 平均回復時間一樣為約 9.53
## 5.4
行程資料如下：

行程	分割時間	優先順序（數字小優先）
P₁	2	1
P₂	1	3
P₃	8	4
P₄	4	2
P₅	3	5
假設到達時間皆為 0，順序 P₁~P₅

3. 使用：FCFS、SJF、優先權排班（數字小為高）、RR（時間片=2）
需繪製甘特圖及比較（此處提供其中兩種簡略答案）：

FCFS 順序： P₁ → P₂ → P₃ → P₄ → P₅

SJF 順序： P₂ → P₁ → P₅ → P₄ → P₃

優先權： P₁ → P₄ → P₂ → P₃ → P₅

→ 建議繪製時間軸與每個程式開始、結束時間，再推回復與等待時間。

4. 平均回復時間與等待時間的計算方式：
$回復時間 = 結束時間 - 到達時間$

$等待時間 = 回復時間 - 執行時間$

## 5.5 RR排班
所有行程皆可搶先，使用 Round Robin（時間片2）進行
→ 記得依照時間輪轉處理，並追蹤每個行程完成時間與回復時間。建議畫時間軸甘特圖輔助。

## 5.6 不同時間片長對系統效能的影響：
時間片太長：

RR 排班會趨近 FCFS，公平性降低，反應時間差

系統互動性變差，不適合需要即時回應的系統

時間片太短：

切換行程的開銷（context switch）太頻繁，浪費CPU時間

效能下降，增加系統負載

理想時間片長度應該權衡：

使用者互動反應快

Context switch overhead 不可太高（常建議為行程平均執行時間的 20%）

## 5.7 多種排班演算法效率比較
使用者互動程式需低延遲，系統背景工作需高吞吐量，考慮：

1. FCFS vs SJF：

FCFS： 簡單但容易造成短行程被長行程「飢餓」

SJF： 理論上平均等待時間最低，但需預測執行時間（可能不準）

2. RR vs FCFS：

RR： 反應時間快，適合互動式使用者程序

FCFS： 一旦長程序先進入，短程序會等太久，互動性差

3. RR vs SJF：

RR 不需預知執行時間，但平均等待時間可能較高

SJF 須要預測，但平均等待時間表現較佳

4. 結論：
沒有一種演算法在所有情況下都最好，通常需根據程式性質選擇演算法，互動程式適合RR，批次適合SJF。

## 5.8 CPU排班演算法在處理I/O密集與CPU密集程式時的影響：
I/O密集：

等待時間較多，執行時間短，頻繁進入I/O

使用RR或多級佇列有利，因為能快速輪轉回來執行I/O完成後的行程

CPU密集：

一次執行較久，輪轉不利（會被頻繁打斷）

適合使用時間片較長的方式（或使用優先排班）

## 5.9 PCS 與 SCS 差異：
PCS（Process-Contention Scope）
→ 執行緒競爭在使用者層級中排程（使用者程式控制）
→ 適用多對一或多對多模型

SCS（System-Contention Scope）
→ 執行緒在系統核心層級中排程（由OS排程器處理）
→ 通常一對一模型使用，具備更公平的CPU使用機會

## 5.10 UNIX 排程器的演進：
早期 UNIX：

使用簡單的優先權加 aging 策略

優先權會隨時間動態調整避免飢餓

現代 UNIX（如 Linux CFS）：

使用公平分享概念（Completely Fair Scheduler）

排程與行程使用CPU時間比例有關

允許多核處理、支援複雜應用與高互動性

