---
title: cmu15445學習筆記
description: 筆記
date: 2024-10-12
tags: ["code","c++","cmu15445"]
---

# Database中的儲存方式

## Lab1 LRU-K-Algorithm

### LRU-Algorithm
- 對於資料庫中的CRUD操作，使用lru可以將時間變成O(1)，單如何實作?
  - 資料庫中為key-value操作，不難想像用hash-map完成，但這樣搬移資料不為O(1)
  - 因此使用double-linkedlist可以實現對於資料搬移的O(1)，而因為希望達到key被刪除時，對應cache中value也被刪除
- 因此將`list<int>`改為`list<pair<int,int>>`為cache
- `unordered_map<int,pair<int,int>::iterator>record`為紀錄cache的record
  - 這邊使用`pair<int,int>::iterator`而非`pair<int,int>`的原因為
  1. record只記錄資料而不做新增，新增是在cache的list上做，而record只需要將對應的key值指向即可
  2. 維護list中的順序，確保最長訪問的數據在list的頭

#### Leetcode 146
- 使用此題當做範例
```c++
#include <bits/stdc++.h>
using namespace std;
class LRUCache {
public:
    list<pair<int,int>> cache;
    unordered_map<int,list<pair<int,int>>::iterator> cacheRecord;
    int size;
    LRUCache(int capacity) {
        size = capacity;
    }
    
    int get(int key) {
        auto it = cacheRecord.find(key);
        if(it != cacheRecord.end()){
            cache.splice(cache.begin(),cache,cacheRecord[key]);
            cacheRecord[key] = cache.begin();
            return cacheRecord[key]->second;
        }
        return -1;
    }
    
    void put(int key, int value) {
        auto it = cacheRecord.find(key);
        if(it != cacheRecord.end()){
            cache.splice(cache.begin(),cache,cacheRecord[key]);
            cacheRecord[key] = cache.begin();
            cache.begin()->second = value;
        }else{
            if(cacheRecord.size() == size){
                int k = cache.back().first;
                cacheRecord.erase(k);
                cache.pop_back();
            }
            auto data = make_pair(key,value);
            cache.push_front(data);
            cacheRecord[key] = cache.begin();
        }
    }
};
```
