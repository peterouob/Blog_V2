---
title: 經典併發問題
description: 使用 Golang 解決經典併發問題
date: 2025-05-03
tags: ["code","go"]
---

# 何謂死鎖


# 哲學家就餐問題

## 問題描述
```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

type Chopstick struct {
	sync.Mutex
}

type Philosopher struct {
	name           string
	leftChopstick  *Chopstick
	rightChopstick *Chopstick
	status         string
}

func (p *Philosopher) dine() {
	for {
		mark(p, "冥想")
		randomPause(10)
		mark(p, "餓了")
		p.leftChopstick.Lock()
		mark(p, "拿左邊快子")
		randomPause(100)
		p.rightChopstick.Lock()
		mark(p, "吃飯")
		randomPause(10)
		p.rightChopstick.Unlock()
		p.leftChopstick.Unlock()
	}
}

func randomPause(max int) {
	time.Sleep(time.Duration(rand.Intn(max)) * time.Millisecond)
}

func mark(p *Philosopher, action string) {
	fmt.Printf("%s start %s\n", p.name, action)
	p.status = fmt.Sprintf("%s start%s", p.status, action)
}

func main() {
	count := 5
	chopstick := make([]*Chopstick, count)
	for i := 0; i < count; i++ {
		chopstick[i] = new(Chopstick)
	}
	names := []string{"哲學家1", "哲學家2", "哲學家3", "哲學家4", "哲學家5"}
	philosophers := make([]*Philosopher, count)
	for i := 0; i < count; i++ {
		philosophers[i] = &Philosopher{
			name:           names[i],
			leftChopstick:  chopstick[i],
			rightChopstick: chopstick[(i+1)%count],
		}
			go philosophers[i].dine()
	}

	select {}
}
```

## 解決方式1
- 限制就餐人數
- 從發生死鎖的條件中發現
```go
if i >= 1 {
			go philosophers[i-1].dine()
		}
```

# 理髮師問題
# 水工廠問題
# fizz buzz
