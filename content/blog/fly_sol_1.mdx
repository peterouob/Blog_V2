---
title: 基本搜尋
description: 學習算法
date: 2024-10-21
tags: ["code", "c++", "fly"]
---

## 1.poj1321

- 類似8皇后,使用遞歸解

```c++
#include <iostream>
using namespace std;

const int N = 10;

char g[N][N];
bool cols[N];
int n=0,k=0;
int ans;

void dfs(int col,int num){
    if(col == n){
        if(num == k) ans ++;
        return;
    }
    for(int i=0;i<n;i++){
        if(!cols[i] && g[col][i] == '#'){
            cols[i] = true;
            dfs(col+1,num+1);
            cols[i] = false;
        }
    }
    dfs(col+1,num);
}

int main() {
    while (cin >> n >> k)
    {
        if(n == -1 && k == -1) break;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                cin >> g[i][j];
            }
        }
        ans = 0;
        dfs(0,0);
        cout << ans << '\n';
    }
}
```

## 2.poj2251

- 3D BFS,因為有x,y,z所以用class存取比較方便,也可以用tuple
- 每次走過都將mp設為#,避免重複走導致TLE

```c++
#include <iostream>
#include <stdio.h>
#include <queue>

using namespace std;

int l, r, c;
char mp[31][31][31]; // z x y
int vis[31][31][31];
int s_x, s_y, s_z; // start
int e_x, e_y, e_z; // end

int d_x[6] = {0, 0, -1, 0, 1, 0};
int d_y[6] = {0, 0, 0, 1, 0, -1};
int d_z[6] = {1, -1, 0, 0, 0, 0};

class Point
{
public:
    Point(int x = 0, int y = 0, int z = 0) : _x(x), _y(y), _z(z) {};
    int _x, _y, _z;
};

int bfs()
{
    queue<Point> q;
    q.push(Point(s_x, s_y, s_z));
    vis[s_z][s_x][s_y] = 0;
    while (q.size())
    {
        Point p = q.front();
        q.pop();
        if (p._x == e_x && p._y == e_y && p._z == e_z)
            return vis[e_z][e_x][e_y];
        for (int i = 0; i < 6; i++)
        {
            int n_x = p._x + d_x[i];
            int n_y = p._y + d_y[i];
            int n_z = p._z + d_z[i];
            if (mp[n_z][n_x][n_y] != '#' && n_x >= 0 && n_x < r && n_y >= 0 && n_y < c && n_z >= 0 && n_z < l )
            {
                q.push(Point(n_x, n_y, n_z));
                vis[n_z][n_x][n_y] = vis[p._z][p._x][p._y] + 1;
                mp[n_z][n_x][n_y] = '#';
            }
        }
    }
    return -1;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    while (cin >> l >> r >> c)
    {
        if (l == 0 && r == 0 && c == 0)
            return 0;
        for (int i = 0; i < l; i++)
        {
            for (int j = 0; j < r; j++)
            {
                for (int k = 0; k < c; k++)
                {
                    cin >> mp[i][j][k];
                    if (mp[i][j][k] == 'S')
                    {
                        s_z = i;
                        s_x = j;
                        s_y = k;
                    }
                    else if (mp[i][j][k] == 'E')
                    {
                        e_z = i;
                        e_x = j;
                        e_y = k;
                    }
                }
            }
        }
        memset(vis,-1,sizeof(vis));
        int ans = bfs();
        ans == -1 ? printf("Trapped!\n") : printf("Escaped in %d minute(s).\n", ans);
    }
}
```

## 3.poj3278

- dis[now]+1代表從現在節點移動到下一個節點的最短距離，下一個節點有可能是dis[now+1]/dis[now-1]/dis[now*2]
- 如果說是小於的話，就跟新值

```c++
#include <iostream>
#include <queue>
#include <string.h>
using namespace std;

const int maxn = 100000;
int n,k,dis[maxn+1],now;
queue<int> q;

int main(){
    while(cin >> n >> k){
        memset(dis,0x3f,sizeof(dis));
        q.push(n);
        dis[n] = 0;
        while(q.size()){
            now = q.front();
            q.pop();
            if(now + 1 <= maxn && dis[now]+1 < dis[now+1]){
                q.push(now+1);
                dis[now+1] = dis[now]+1;
            }
            if(now-1 >= 0 && dis[now]+1 < dis[now-1]){
                q.push(now-1);
                dis[now-1] = dis[now]+1;
            }
            if(now*2 <= maxn && dis[now]+1 < dis[now*2]){
                q.push(now*2);
                dis[now*2] = dis[now]+1;
            }
        }
        cout << dis[k] << '\n';
    }
}
```
